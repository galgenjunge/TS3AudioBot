// TSLib - A free TeamSpeak 3 and 5 client library
// Copyright (C) 2017  TSLib contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.
// <auto-generated />

















using System;
using TSLib.Helper;
using TSLib.Messages;

#nullable enable
namespace TSLib.Query
{
	partial class TsQueryClient
	{
		
		public override event NotifyEventHandler<ChannelChanged>? OnChannelChanged;
		public override event EventHandler<ChannelChanged>? OnEachChannelChanged;
		public override event NotifyEventHandler<ChannelCreated>? OnChannelCreated;
		public override event EventHandler<ChannelCreated>? OnEachChannelCreated;
		public override event NotifyEventHandler<ChannelDeleted>? OnChannelDeleted;
		public override event EventHandler<ChannelDeleted>? OnEachChannelDeleted;
		public override event NotifyEventHandler<ChannelEdited>? OnChannelEdited;
		public override event EventHandler<ChannelEdited>? OnEachChannelEdited;
		public override event NotifyEventHandler<ChannelMoved>? OnChannelMoved;
		public override event EventHandler<ChannelMoved>? OnEachChannelMoved;
		public override event NotifyEventHandler<ChannelPasswordChanged>? OnChannelPasswordChanged;
		public override event EventHandler<ChannelPasswordChanged>? OnEachChannelPasswordChanged;
		public override event NotifyEventHandler<ClientEnterView>? OnClientEnterView;
		public override event EventHandler<ClientEnterView>? OnEachClientEnterView;
		public override event NotifyEventHandler<ClientLeftView>? OnClientLeftView;
		public override event EventHandler<ClientLeftView>? OnEachClientLeftView;
		public override event NotifyEventHandler<ClientMoved>? OnClientMoved;
		public override event EventHandler<ClientMoved>? OnEachClientMoved;
		public override event NotifyEventHandler<ServerEdited>? OnServerEdited;
		public override event EventHandler<ServerEdited>? OnEachServerEdited;
		public override event NotifyEventHandler<TextMessage>? OnTextMessage;
		public override event EventHandler<TextMessage>? OnEachTextMessage;
		public override event NotifyEventHandler<TokenUsed>? OnTokenUsed;
		public override event EventHandler<TokenUsed>? OnEachTokenUsed;


		private void InvokeEvent(LazyNotification lazyNotification)
		{
			var ntf = lazyNotification.Notifications;
			switch (lazyNotification.NotifyType)
			{
			
			case NotificationType.ChannelChanged: {
				var ntfc = (ChannelChanged[])ntf;
				OnChannelChanged?.Invoke(this, ntfc);
				var ev = OnEachChannelChanged;
				foreach(var that in ntfc) {
					ev?.Invoke(this, that);
				}
				break;
			}
			
			case NotificationType.ChannelCreated: {
				var ntfc = (ChannelCreated[])ntf;
				OnChannelCreated?.Invoke(this, ntfc);
				var ev = OnEachChannelCreated;
				foreach(var that in ntfc) {
					ev?.Invoke(this, that);
				}
				break;
			}
			
			case NotificationType.ChannelDeleted: {
				var ntfc = (ChannelDeleted[])ntf;
				OnChannelDeleted?.Invoke(this, ntfc);
				var ev = OnEachChannelDeleted;
				foreach(var that in ntfc) {
					ev?.Invoke(this, that);
				}
				break;
			}
			
			case NotificationType.ChannelEdited: {
				var ntfc = (ChannelEdited[])ntf;
				OnChannelEdited?.Invoke(this, ntfc);
				var ev = OnEachChannelEdited;
				foreach(var that in ntfc) {
					ev?.Invoke(this, that);
				}
				break;
			}
			
			case NotificationType.ChannelMoved: {
				var ntfc = (ChannelMoved[])ntf;
				OnChannelMoved?.Invoke(this, ntfc);
				var ev = OnEachChannelMoved;
				foreach(var that in ntfc) {
					ev?.Invoke(this, that);
				}
				break;
			}
			
			case NotificationType.ChannelPasswordChanged: {
				var ntfc = (ChannelPasswordChanged[])ntf;
				OnChannelPasswordChanged?.Invoke(this, ntfc);
				var ev = OnEachChannelPasswordChanged;
				foreach(var that in ntfc) {
					ev?.Invoke(this, that);
				}
				break;
			}
			
			case NotificationType.ClientEnterView: {
				var ntfc = (ClientEnterView[])ntf;
				OnClientEnterView?.Invoke(this, ntfc);
				var ev = OnEachClientEnterView;
				foreach(var that in ntfc) {
					ev?.Invoke(this, that);
				}
				break;
			}
			
			case NotificationType.ClientLeftView: {
				var ntfc = (ClientLeftView[])ntf;
				OnClientLeftView?.Invoke(this, ntfc);
				var ev = OnEachClientLeftView;
				foreach(var that in ntfc) {
					ev?.Invoke(this, that);
				}
				break;
			}
			
			case NotificationType.ClientMoved: {
				var ntfc = (ClientMoved[])ntf;
				OnClientMoved?.Invoke(this, ntfc);
				var ev = OnEachClientMoved;
				foreach(var that in ntfc) {
					ev?.Invoke(this, that);
				}
				break;
			}
			
			case NotificationType.ServerEdited: {
				var ntfc = (ServerEdited[])ntf;
				OnServerEdited?.Invoke(this, ntfc);
				var ev = OnEachServerEdited;
				foreach(var that in ntfc) {
					ev?.Invoke(this, that);
				}
				break;
			}
			
			case NotificationType.TextMessage: {
				var ntfc = (TextMessage[])ntf;
				OnTextMessage?.Invoke(this, ntfc);
				var ev = OnEachTextMessage;
				foreach(var that in ntfc) {
					ev?.Invoke(this, that);
				}
				break;
			}
			
			case NotificationType.TokenUsed: {
				var ntfc = (TokenUsed[])ntf;
				OnTokenUsed?.Invoke(this, ntfc);
				var ev = OnEachTokenUsed;
				foreach(var that in ntfc) {
					ev?.Invoke(this, that);
				}
				break;
			}
			
			case NotificationType.CommandError: break;
			case NotificationType.Unknown:
			default:
				throw Tools.UnhandledDefault(lazyNotification.NotifyType);
			}
		}
	}
}
